"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeSecureSecretSettings, TypeSecureValueError, TypeUser, TypeSecureValue, TypePrivacyRule, TypePasswordKdfAlgo, TypeSecurePasswordKdfAlgo, TypeWebAuthorization, TypeSecureRequiredType, TypeWallPaper, TypeAuthorization



class AuthorizationForm(TLObject):
    CONSTRUCTOR_ID = 0xad2e1cd8
    SUBCLASS_OF_ID = 0x78049a94

    def __init__(self, required_types, values, errors, users, privacy_policy_url=None):
        """
        :param List[TypeSecureRequiredType] required_types:
        :param List[TypeSecureValue] values:
        :param List[TypeSecureValueError] errors:
        :param List[TypeUser] users:
        :param Optional[str] privacy_policy_url:

        Constructor for account.AuthorizationForm: Instance of AuthorizationForm.
        """
        self.required_types = required_types  # type: List[TypeSecureRequiredType]
        self.values = values  # type: List[TypeSecureValue]
        self.errors = errors  # type: List[TypeSecureValueError]
        self.users = users  # type: List[TypeUser]
        self.privacy_policy_url = privacy_policy_url  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'AuthorizationForm',
            'required_types': [] if self.required_types is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.required_types],
            'values': [] if self.values is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.values],
            'errors': [] if self.errors is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.errors],
            'users': [] if self.users is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.users],
            'privacy_policy_url': self.privacy_policy_url
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\x1c.\xad',
            struct.pack('<I', (0 if self.privacy_policy_url is None or self.privacy_policy_url is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.required_types)),b''.join(bytes(x) for x in self.required_types),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.values)),b''.join(bytes(x) for x in self.values),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.errors)),b''.join(bytes(x) for x in self.errors),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'' if self.privacy_policy_url is None or self.privacy_policy_url is False else (self.serialize_bytes(self.privacy_policy_url)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        reader.read_int()
        _required_types = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _required_types.append(_x)

        reader.read_int()
        _values = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _values.append(_x)

        reader.read_int()
        _errors = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _errors.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        if flags & 1:
            _privacy_policy_url = reader.tgread_string()
        else:
            _privacy_policy_url = None
        return cls(required_types=_required_types, values=_values, errors=_errors, users=_users, privacy_policy_url=_privacy_policy_url)


class Authorizations(TLObject):
    CONSTRUCTOR_ID = 0x1250abde
    SUBCLASS_OF_ID = 0xbf5e0ff

    def __init__(self, authorizations):
        """
        :param List[TypeAuthorization] authorizations:

        Constructor for account.Authorizations: Instance of Authorizations.
        """
        self.authorizations = authorizations  # type: List[TypeAuthorization]

    def to_dict(self):
        return {
            '_': 'Authorizations',
            'authorizations': [] if self.authorizations is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.authorizations]
        }

    def __bytes__(self):
        return b''.join((
            b'\xde\xabP\x12',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.authorizations)),b''.join(bytes(x) for x in self.authorizations),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _authorizations = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _authorizations.append(_x)

        return cls(authorizations=_authorizations)


class Password(TLObject):
    CONSTRUCTOR_ID = 0xad2641f8
    SUBCLASS_OF_ID = 0x53a211a3

    def __init__(self, new_algo, new_secure_algo, secure_random, has_recovery=None, has_secure_values=None, has_password=None, current_algo=None, srp_B=None, srp_id=None, hint=None, email_unconfirmed_pattern=None):
        """
        :param TypePasswordKdfAlgo new_algo:
        :param TypeSecurePasswordKdfAlgo new_secure_algo:
        :param bytes secure_random:
        :param Optional[bool] has_recovery:
        :param Optional[bool] has_secure_values:
        :param Optional[bool] has_password:
        :param Optional[TypePasswordKdfAlgo] current_algo:
        :param Optional[bytes] srp_B:
        :param Optional[int] srp_id:
        :param Optional[str] hint:
        :param Optional[str] email_unconfirmed_pattern:

        Constructor for account.Password: Instance of Password.
        """
        self.new_algo = new_algo  # type: TypePasswordKdfAlgo
        self.new_secure_algo = new_secure_algo  # type: TypeSecurePasswordKdfAlgo
        self.secure_random = secure_random  # type: bytes
        self.has_recovery = has_recovery  # type: Optional[bool]
        self.has_secure_values = has_secure_values  # type: Optional[bool]
        self.has_password = has_password  # type: Optional[bool]
        self.current_algo = current_algo  # type: Optional[TypePasswordKdfAlgo]
        self.srp_B = srp_B  # type: Optional[bytes]
        self.srp_id = srp_id  # type: Optional[int]
        self.hint = hint  # type: Optional[str]
        self.email_unconfirmed_pattern = email_unconfirmed_pattern  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'Password',
            'new_algo': self.new_algo.to_dict() if isinstance(self.new_algo, TLObject) else self.new_algo,
            'new_secure_algo': self.new_secure_algo.to_dict() if isinstance(self.new_secure_algo, TLObject) else self.new_secure_algo,
            'secure_random': self.secure_random,
            'has_recovery': self.has_recovery,
            'has_secure_values': self.has_secure_values,
            'has_password': self.has_password,
            'current_algo': self.current_algo.to_dict() if isinstance(self.current_algo, TLObject) else self.current_algo,
            'srp_B': self.srp_B,
            'srp_id': self.srp_id,
            'hint': self.hint,
            'email_unconfirmed_pattern': self.email_unconfirmed_pattern
        }

    def __bytes__(self):
        assert ((self.has_password or self.has_password is not None) and (self.current_algo or self.current_algo is not None) and (self.srp_B or self.srp_B is not None) and (self.srp_id or self.srp_id is not None)) or ((self.has_password is None or self.has_password is False) and (self.current_algo is None or self.current_algo is False) and (self.srp_B is None or self.srp_B is False) and (self.srp_id is None or self.srp_id is False)), 'has_password, current_algo, srp_B, srp_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xf8A&\xad',
            struct.pack('<I', (0 if self.has_recovery is None or self.has_recovery is False else 1) | (0 if self.has_secure_values is None or self.has_secure_values is False else 2) | (0 if self.has_password is None or self.has_password is False else 4) | (0 if self.current_algo is None or self.current_algo is False else 4) | (0 if self.srp_B is None or self.srp_B is False else 4) | (0 if self.srp_id is None or self.srp_id is False else 4) | (0 if self.hint is None or self.hint is False else 8) | (0 if self.email_unconfirmed_pattern is None or self.email_unconfirmed_pattern is False else 16)),
            b'' if self.current_algo is None or self.current_algo is False else (bytes(self.current_algo)),
            b'' if self.srp_B is None or self.srp_B is False else (self.serialize_bytes(self.srp_B)),
            b'' if self.srp_id is None or self.srp_id is False else (struct.pack('<q', self.srp_id)),
            b'' if self.hint is None or self.hint is False else (self.serialize_bytes(self.hint)),
            b'' if self.email_unconfirmed_pattern is None or self.email_unconfirmed_pattern is False else (self.serialize_bytes(self.email_unconfirmed_pattern)),
            bytes(self.new_algo),
            bytes(self.new_secure_algo),
            self.serialize_bytes(self.secure_random),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _has_recovery = bool(flags & 1)
        _has_secure_values = bool(flags & 2)
        _has_password = bool(flags & 4)
        if flags & 4:
            _current_algo = reader.tgread_object()
        else:
            _current_algo = None
        if flags & 4:
            _srp_B = reader.tgread_bytes()
        else:
            _srp_B = None
        if flags & 4:
            _srp_id = reader.read_long()
        else:
            _srp_id = None
        if flags & 8:
            _hint = reader.tgread_string()
        else:
            _hint = None
        if flags & 16:
            _email_unconfirmed_pattern = reader.tgread_string()
        else:
            _email_unconfirmed_pattern = None
        _new_algo = reader.tgread_object()
        _new_secure_algo = reader.tgread_object()
        _secure_random = reader.tgread_bytes()
        return cls(new_algo=_new_algo, new_secure_algo=_new_secure_algo, secure_random=_secure_random, has_recovery=_has_recovery, has_secure_values=_has_secure_values, has_password=_has_password, current_algo=_current_algo, srp_B=_srp_B, srp_id=_srp_id, hint=_hint, email_unconfirmed_pattern=_email_unconfirmed_pattern)


class PasswordInputSettings(TLObject):
    CONSTRUCTOR_ID = 0xc23727c9
    SUBCLASS_OF_ID = 0xc426ca6

    def __init__(self, new_algo=None, new_password_hash=None, hint=None, email=None, new_secure_settings=None):
        """
        :param Optional[TypePasswordKdfAlgo] new_algo:
        :param Optional[bytes] new_password_hash:
        :param Optional[str] hint:
        :param Optional[str] email:
        :param Optional[TypeSecureSecretSettings] new_secure_settings:

        Constructor for account.PasswordInputSettings: Instance of PasswordInputSettings.
        """
        self.new_algo = new_algo  # type: Optional[TypePasswordKdfAlgo]
        self.new_password_hash = new_password_hash  # type: Optional[bytes]
        self.hint = hint  # type: Optional[str]
        self.email = email  # type: Optional[str]
        self.new_secure_settings = new_secure_settings  # type: Optional[TypeSecureSecretSettings]

    def to_dict(self):
        return {
            '_': 'PasswordInputSettings',
            'new_algo': self.new_algo.to_dict() if isinstance(self.new_algo, TLObject) else self.new_algo,
            'new_password_hash': self.new_password_hash,
            'hint': self.hint,
            'email': self.email,
            'new_secure_settings': self.new_secure_settings.to_dict() if isinstance(self.new_secure_settings, TLObject) else self.new_secure_settings
        }

    def __bytes__(self):
        assert ((self.new_algo or self.new_algo is not None) and (self.new_password_hash or self.new_password_hash is not None) and (self.hint or self.hint is not None)) or ((self.new_algo is None or self.new_algo is False) and (self.new_password_hash is None or self.new_password_hash is False) and (self.hint is None or self.hint is False)), 'new_algo, new_password_hash, hint parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b"\xc9'7\xc2",
            struct.pack('<I', (0 if self.new_algo is None or self.new_algo is False else 1) | (0 if self.new_password_hash is None or self.new_password_hash is False else 1) | (0 if self.hint is None or self.hint is False else 1) | (0 if self.email is None or self.email is False else 2) | (0 if self.new_secure_settings is None or self.new_secure_settings is False else 4)),
            b'' if self.new_algo is None or self.new_algo is False else (bytes(self.new_algo)),
            b'' if self.new_password_hash is None or self.new_password_hash is False else (self.serialize_bytes(self.new_password_hash)),
            b'' if self.hint is None or self.hint is False else (self.serialize_bytes(self.hint)),
            b'' if self.email is None or self.email is False else (self.serialize_bytes(self.email)),
            b'' if self.new_secure_settings is None or self.new_secure_settings is False else (bytes(self.new_secure_settings)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _new_algo = reader.tgread_object()
        else:
            _new_algo = None
        if flags & 1:
            _new_password_hash = reader.tgread_bytes()
        else:
            _new_password_hash = None
        if flags & 1:
            _hint = reader.tgread_string()
        else:
            _hint = None
        if flags & 2:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 4:
            _new_secure_settings = reader.tgread_object()
        else:
            _new_secure_settings = None
        return cls(new_algo=_new_algo, new_password_hash=_new_password_hash, hint=_hint, email=_email, new_secure_settings=_new_secure_settings)


class PasswordSettings(TLObject):
    CONSTRUCTOR_ID = 0x9a5c33e5
    SUBCLASS_OF_ID = 0xd23fb078

    def __init__(self, email=None, secure_settings=None):
        """
        :param Optional[str] email:
        :param Optional[TypeSecureSecretSettings] secure_settings:

        Constructor for account.PasswordSettings: Instance of PasswordSettings.
        """
        self.email = email  # type: Optional[str]
        self.secure_settings = secure_settings  # type: Optional[TypeSecureSecretSettings]

    def to_dict(self):
        return {
            '_': 'PasswordSettings',
            'email': self.email,
            'secure_settings': self.secure_settings.to_dict() if isinstance(self.secure_settings, TLObject) else self.secure_settings
        }

    def __bytes__(self):
        return b''.join((
            b'\xe53\\\x9a',
            struct.pack('<I', (0 if self.email is None or self.email is False else 1) | (0 if self.secure_settings is None or self.secure_settings is False else 2)),
            b'' if self.email is None or self.email is False else (self.serialize_bytes(self.email)),
            b'' if self.secure_settings is None or self.secure_settings is False else (bytes(self.secure_settings)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 2:
            _secure_settings = reader.tgread_object()
        else:
            _secure_settings = None
        return cls(email=_email, secure_settings=_secure_settings)


class PrivacyRules(TLObject):
    CONSTRUCTOR_ID = 0x554abb6f
    SUBCLASS_OF_ID = 0xb55aba82

    def __init__(self, rules, users):
        """
        :param List[TypePrivacyRule] rules:
        :param List[TypeUser] users:

        Constructor for account.PrivacyRules: Instance of PrivacyRules.
        """
        self.rules = rules  # type: List[TypePrivacyRule]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'PrivacyRules',
            'rules': [] if self.rules is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.rules],
            'users': [] if self.users is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'o\xbbJU',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(rules=_rules, users=_users)


class SentEmailCode(TLObject):
    CONSTRUCTOR_ID = 0x811f854f
    SUBCLASS_OF_ID = 0x69f3c06e

    def __init__(self, email_pattern, length):
        """
        :param str email_pattern:
        :param int length:

        Constructor for account.SentEmailCode: Instance of SentEmailCode.
        """
        self.email_pattern = email_pattern  # type: str
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'SentEmailCode',
            'email_pattern': self.email_pattern,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'O\x85\x1f\x81',
            self.serialize_bytes(self.email_pattern),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email_pattern = reader.tgread_string()
        _length = reader.read_int()
        return cls(email_pattern=_email_pattern, length=_length)


class Takeout(TLObject):
    CONSTRUCTOR_ID = 0x4dba4501
    SUBCLASS_OF_ID = 0x843ebe85

    def __init__(self, id):
        """
        :param int id:

        Constructor for account.Takeout: Instance of Takeout.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'Takeout',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x01E\xbaM',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class TmpPassword(TLObject):
    CONSTRUCTOR_ID = 0xdb64fd34
    SUBCLASS_OF_ID = 0xb064992d

    def __init__(self, tmp_password, valid_until):
        """
        :param bytes tmp_password:
        :param int valid_until:

        Constructor for account.TmpPassword: Instance of TmpPassword.
        """
        self.tmp_password = tmp_password  # type: bytes
        self.valid_until = valid_until  # type: int

    def to_dict(self):
        return {
            '_': 'TmpPassword',
            'tmp_password': self.tmp_password,
            'valid_until': self.valid_until
        }

    def __bytes__(self):
        return b''.join((
            b'4\xfdd\xdb',
            self.serialize_bytes(self.tmp_password),
            struct.pack('<i', self.valid_until),
        ))

    @classmethod
    def from_reader(cls, reader):
        _tmp_password = reader.tgread_bytes()
        _valid_until = reader.read_int()
        return cls(tmp_password=_tmp_password, valid_until=_valid_until)


class WallPapers(TLObject):
    CONSTRUCTOR_ID = 0x702b65a9
    SUBCLASS_OF_ID = 0xa2c548fd

    def __init__(self, hash, wallpapers):
        """
        :param int hash:
        :param List[TypeWallPaper] wallpapers:

        Constructor for account.WallPapers: Instance of either WallPapersNotModified, WallPapers.
        """
        self.hash = hash  # type: int
        self.wallpapers = wallpapers  # type: List[TypeWallPaper]

    def to_dict(self):
        return {
            '_': 'WallPapers',
            'hash': self.hash,
            'wallpapers': [] if self.wallpapers is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.wallpapers]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa9e+p',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.wallpapers)),b''.join(bytes(x) for x in self.wallpapers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _wallpapers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _wallpapers.append(_x)

        return cls(hash=_hash, wallpapers=_wallpapers)


class WallPapersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x1c199183
    SUBCLASS_OF_ID = 0xa2c548fd

    def to_dict(self):
        return {
            '_': 'WallPapersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\x91\x19\x1c',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class WebAuthorizations(TLObject):
    CONSTRUCTOR_ID = 0xed56c9fc
    SUBCLASS_OF_ID = 0x9a365b32

    def __init__(self, authorizations, users):
        """
        :param List[TypeWebAuthorization] authorizations:
        :param List[TypeUser] users:

        Constructor for account.WebAuthorizations: Instance of WebAuthorizations.
        """
        self.authorizations = authorizations  # type: List[TypeWebAuthorization]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'WebAuthorizations',
            'authorizations': [] if self.authorizations is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.authorizations],
            'users': [] if self.users is None else [x.to_dict() if isinstance(x, TLObject) else x for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xfc\xc9V\xed',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.authorizations)),b''.join(bytes(x) for x in self.authorizations),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _authorizations = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _authorizations.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(authorizations=_authorizations, users=_users)

